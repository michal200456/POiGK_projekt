#include <raylib.h>
#include <math.h>

int main(void)
{
    InitWindow(800, 600, "Animowane ramię robota 3D");
    Camera3D camera = {0};
    camera.position = (Vector3){4.0f, 4.0f, 4.0f};  // pozycja kamery
    camera.target = (Vector3){0.0f, 1.0f, 0.0f};    // punkt na który patrzy
    camera.up = (Vector3){0.0f, 1.0f, 0.0f};        // góra kamery
    camera.fovy = 45.0f;
    camera.type = CAMERA_PERSPECTIVE;

    SetTargetFPS(60);

    while (!WindowShouldClose())
    {
        float time = GetTime();

        // Animowane kąty segmentów
        float baseAngle = 45.0f * sinf(time);
        float forearmAngle = 30.0f * cosf(time * 1.5f);

        BeginDrawing();
        ClearBackground(RAYWHITE);
        BeginMode3D(camera);

        DrawGrid(10, 1.0f);

        // Segment bazowy (np. prostokątna bryła)
        Matrix baseTransform = MatrixRotateY(DEG2RAD * baseAngle);
        baseTransform.m30 = 0.0f;  // pozycja X
        baseTransform.m31 = 0.5f;  // pozycja Y (trochę do góry, by było nad ziemią)
        baseTransform.m32 = 0.0f;  // pozycja Z

        // Rysujemy segment bazowy jako box (sześcian wydłużony)
        DrawCubeV((Vector3){0, 0, 0}, (Vector3){0.5f, 1.0f, 0.5f}, BLUE);

        // Zastosuj transformację bazowego segmentu
        rlPushMatrix();
        rlMultMatrixf(MatrixToFloat(baseTransform));

        // Segment przedramienia - przesunięty na koniec bazowego segmentu w osi Y
        Matrix forearmTransform = MatrixTranslate(0.0f, 1.0f, 0.0f);
        forearmTransform = MatrixMultiply(forearmTransform, MatrixRotateZ(DEG2RAD * forearmAngle));

        rlPushMatrix();
        rlMultMatrixf(MatrixToFloat(forearmTransform));

        DrawCubeV((Vector3){0, 0, 0}, (Vector3){0.4f, 0.8f, 0.4f}, RED);
        rlPopMatrix();

        rlPopMatrix();

        EndMode3D();
        DrawText("Animowane ramię robota 3D", 10, 10, 20, DARKGRAY);
        EndDrawing();
    }

    CloseWindow();

    return 0;
}
