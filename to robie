#include <raylib.h>
#include <math.h>
#include <rlgl.h>

typedef struct {
    Vector3 position;
    float yaw;
    float pitch;  
    Camera3D camera;
} MouseCamera;

Color podstawka = {123,130,122,255};
Color dolnyprzegub = {254,238,0,255};

void InitMouseCamera(MouseCamera *mc, Vector3 pos) {
    mc->position = pos;
    mc->yaw = 45.0f;  
    mc->pitch = 0.0f;

    mc->camera.position = pos;
    mc->camera.target = (Vector3){0, 0, 0};
    mc->camera.up = (Vector3){0, 1, 0};
    mc->camera.fovy = 45.0f;
    mc->camera.projection = CAMERA_PERSPECTIVE;

    SetMousePosition(GetScreenWidth() / 2, GetScreenHeight() / 2);
    DisableCursor();
}

void UpdateMouseCamera(MouseCamera *mc) {
    Vector2 mousePos = GetMousePosition();
    Vector2 mouseDelta = { mousePos.x - GetScreenWidth() / 2, mousePos.y - GetScreenHeight() / 2 };

    const float sensitivity = 0.2f;
    mc->yaw += mouseDelta.x * sensitivity;
    mc->pitch -= mouseDelta.y * sensitivity;

    if (mc->pitch > 89.0f) mc->pitch = 89.0f;
    if (mc->pitch < -89.0f) mc->pitch = -89.0f;

    SetMousePosition(GetScreenWidth() / 2, GetScreenHeight() / 2);

    float radYaw = mc->yaw * (PI / 180.0f);
    float radPitch = mc->pitch * (PI / 180.0f);

    mc->camera.position = mc->position;
    mc->camera.target.x = mc->position.x + cosf(radPitch) * cosf(radYaw);
    mc->camera.target.y = mc->position.y + sinf(radPitch);
    mc->camera.target.z = mc->position.z + cosf(radPitch) * sinf(radYaw);
    mc->camera.up = (Vector3){0, 1, 0};
}

void DrawCylinderWireframe(Vector3 pos, float radius, float height, int slices, Color color) {
    for (int i = 0; i < slices; i++) {
        float angle1 = 2*PI*i/slices;
        float angle2 = 2*PI*(i+1)/slices;

        Vector3 p1 = {pos.x + radius*cosf(angle1), pos.y,           pos.z + radius*sinf(angle1)};
        Vector3 p2 = {pos.x + radius*cosf(angle2), pos.y,           pos.z + radius*sinf(angle2)};
        Vector3 p3 = {pos.x + radius*cosf(angle1), pos.y + height,  pos.z + radius*sinf(angle1)};
        Vector3 p4 = {pos.x + radius*cosf(angle2), pos.y + height,  pos.z + radius*sinf(angle2)};

        DrawLine3D(p1, p2, color);
        DrawLine3D(p3, p4, color);
        DrawLine3D(p1, p3, color);
    }
}

int main() {
    InitWindow(800, 800, "robot");
    SetTargetFPS(60);

    MouseCamera myCam;
    InitMouseCamera(&myCam, (Vector3){4.0f, 2.0f, 4.0f});

    while (!WindowShouldClose()) {
        UpdateMouseCamera(&myCam);

        BeginDrawing();
            ClearBackground(RAYWHITE);

            BeginMode3D(myCam.camera);
                DrawGrid(20, 1.0f);

                // Podstawa
                DrawCylinder((Vector3){0,0,0}, 0.5, 0.5, 0.1, 48, podstawka);
                DrawCylinderWireframe((Vector3){0,0,0}, 0.5, 0.1, 48, BLACK);
                DrawCylinder((Vector3){0,0.1,0}, 0.35, 0.35, 0.1, 48, podstawka);
                DrawCylinderWireframe((Vector3){0,0.1,0}, 0.35, 0.1, 48, BLACK);

                // Dolny przegub
                DrawCylinder((Vector3){0,0.2,0}, 0.1, 0.25, 0.32, 48, dolnyprzegub);

                // Ruchomy przegub (walec na górze)
                float przegubHeight = 0.32f;
                Vector3 przegubPosition = {0, 0.2f + przegubHeight, 0};

                rlPushMatrix();
                    rlTranslatef(przegubPosition.x, przegubPosition.y, przegubPosition.z);
                    rlRotatef(-30, 1, 0, 0);  // nachylenie o -30 stopni wokół osi X
                    DrawCylinder((Vector3){0, 0, 0}, 0.065, 0.065, 0.6f, 48, dolnyprzegub);
                    DrawCylinderWireframe((Vector3){0, 0, 0}, 0.065, 0.6f, 48, BLACK);
                rlPopMatrix();

            EndMode3D();

        EndDrawing();
    }

    EnableCursor();
    CloseWindow();
    return 0;
}
