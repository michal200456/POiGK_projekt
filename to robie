#include <raylib.h>
#include <math.h>
#include <rlgl.h>

typedef struct {
    Vector3 position;
    float yaw;
    float pitch;  
    Camera3D camera;
} MouseCamera;

Color podstawka = {123,130,122,255};
Color dolnyprzegub = {254,238,0,255};
void InitMouseCamera(MouseCamera *mc, Vector3 pos) {
    mc->position = pos;
    mc->yaw = 45.0f;  
    mc->pitch = 0.0f;

    mc->camera.position = pos;
    mc->camera.target = (Vector3){0, 0, 0};
    mc->camera.up = (Vector3){0, 1, 0};
    mc->camera.fovy = 45.0f;
    mc->camera.projection = CAMERA_PERSPECTIVE;

    SetMousePosition(GetScreenWidth() / 2, GetScreenHeight() / 2);
    DisableCursor();
}
void UpdateMouseCamera(MouseCamera *mc) {
    Vector2 mousePos = GetMousePosition();
    Vector2 mouseDelta = { mousePos.x - GetScreenWidth() / 2, mousePos.y - GetScreenHeight() / 2 };

    const float sensitivity = 0.2f;
    mc->yaw += mouseDelta.x * sensitivity;
    mc->pitch -= mouseDelta.y * sensitivity;

    if (mc->pitch > 89.0f) mc->pitch = 89.0f;
    if (mc->pitch < -89.0f) mc->pitch = -89.0f;

    SetMousePosition(GetScreenWidth() / 2, GetScreenHeight() / 2);

    float radYaw = mc->yaw * (PI / 180.0f);
    float radPitch = mc->pitch * (PI / 180.0f);

    mc->camera.position = mc->position;
    mc->camera.target.x = mc->position.x + cosf(radPitch) * cosf(radYaw);
    mc->camera.target.y = mc->position.y + sinf(radPitch);
    mc->camera.target.z = mc->position.z + cosf(radPitch) * sinf(radYaw);
    mc->camera.up = (Vector3){0, 1, 0};
}
#include <math.h>
#include <raylib.h>

void DrawCylinderWireframe(Vector3 pos, float radius, float height, int slices, Color color) {
    for (int i = 0; i < slices; i++) {
        float angle1 = 2*PI*i/slices;
        float angle2 = 2*PI*(i+1)/slices;

        Vector3 p1 = {pos.x + radius*cosf(angle1), pos.y,           pos.z + radius*sinf(angle1)};
        Vector3 p2 = {pos.x + radius*cosf(angle2), pos.y,           pos.z + radius*sinf(angle2)};
        Vector3 p3 = {pos.x + radius*cosf(angle1), pos.y + height,  pos.z + radius*sinf(angle1)};
        Vector3 p4 = {pos.x + radius*cosf(angle2), pos.y + height,  pos.z + radius*sinf(angle2)};

        // linia dolna (podstawa)
        DrawLine3D(p1, p2, color);
        // linia górna (pokrywa)
        DrawLine3D(p3, p4, color);
        // linia pionowa (boczna krawędź)
        DrawLine3D(p1, p3, color);
    }
}

int main() {
    InitWindow(800, 800, "robot");
    SetTargetFPS(60);

    MouseCamera myCam;
    InitMouseCamera(&myCam, (Vector3){4.0f, 2.0f, 4.0f});

    while (!WindowShouldClose()) {
        UpdateMouseCamera(&myCam);

        BeginDrawing();
            ClearBackground(RAYWHITE);

            BeginMode3D(myCam.camera);
                DrawGrid(20, 1.0f);
                DrawCylinder((Vector3){0,0,0},0.5,0.5,0.1,48,podstawka);
                DrawCylinderWireframe((Vector3){0,0,0},0.5,0.1,48,BLACK);
                DrawCylinder((Vector3){0,0.1,0},0.35,0.35,0.1,48,podstawka);
                DrawCylinderWireframe((Vector3){0,0.1,0},0.35,0.1,48,BLACK);
                DrawCylinder((Vector3){0,0.2,0},0.1,0.25,0.32,48,dolnyprzegub);
            EndMode3D();

        EndDrawing();
    }

    EnableCursor();
    CloseWindow();
    return 0;
}
